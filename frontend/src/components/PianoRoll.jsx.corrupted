import React from 'react';
import './PianoRoll.css';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { faPlay, faStop, faRecordVinyl, faCog, faPlus, faMinus, faMusic, faGuitar, faDrum, faWaveSquare, faSliders, faVolumeUp, faArrowsAlt } from '@fortawesome/free-solid-svg-icons';
import * as MusicTheory from '../utils/MusicTheory';
import * as MelodyGenerator from '../utils/MelodyGenerator';

const PianoRoll = ({ notes, setNotes, width = 1000, height = 300 }) => {
  // State for note editing and interaction
  const [draggedNote, setDraggedNote] = useState(null);
  const [currentOctave, setCurrentOctave] = useState(4);
  const [mouseDown, setMouseDown] = useState(false);
  const [startPosition, setStartPosition] = useState({ x: 0, y: 0 });
  const [isResizing, setIsResizing] = useState(false);
  const [selectedNote, setSelectedNote] = useState(null);
  
  // Playback controls
  const [isPlaying, setIsPlaying] = useState(false);
  const [isRecording, setIsRecording] = useState(false);
  const [bpm, setBpm] = useState(120);
  const [timeSignature, setTimeSignature] = useState('4/4');
  const [gridResolution, setGridResolution] = useState(16); // 16th notes
  const [autoScroll, setAutoScroll] = useState(true);
  const [playheadPosition, setPlayheadPosition] = useState(0);
  const [viewportStart, setViewportStart] = useState(0); // horizontal scroll position
  
  // Advanced melody editing features
  const [currentKey, setCurrentKey] = useState('C');
  const [currentScale, setCurrentScale] = useState('major');
  const [snapToScale, setSnapToScale] = useState(false);
  const [chordMode, setChordMode] = useState(false);
  const [currentChordType, setCurrentChordType] = useState('maj');
  const [showVelocityEditor, setShowVelocityEditor] = useState(false);
  const [velocityValue, setVelocityValue] = useState(100);
  const [patternMode, setPatternMode] = useState(false);
  const [selectedPattern, setSelectedPattern] = useState('ascending');
  const [showAdvancedControls, setShowAdvancedControls] = useState(false);
  const [quantizeEnabled, setQuantizeEnabled] = useState(false);
  
  // Refs
  const pianoRollRef = useRef(null);
  const gridRef = useRef(null);
  const playheadRef = useRef(null);
  const playIntervalRef = useRef(null);
  
  // Constants for the piano roll
  const NOTE_HEIGHT = 20;
  const GRID_SIZE = 25; // pixels per 16th note
  const OCTAVES = 7; // 7 octaves
  const NOTES_PER_OCTAVE = 12;
  const TOTAL_NOTES = NOTES_PER_OCTAVE * OCTAVES;
  const PIANO_KEY_WIDTH = 60;
  const TIMELINE_HEIGHT = 25;
  const TRANSPORT_HEIGHT = 40;
  const MEASURES = 16; // Number of measures to display
  
  const OCTAVE_C_NOTES = [0, 12, 24, 36, 48, 60, 72, 84];
  
  const NOTE_NAMES = [
    'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'
  ];

  // Create an array of all note positions
  const notePositions = Array(TOTAL_NOTES).fill().map((_, i) => {
    const octave = Math.floor(i / NOTES_PER_OCTAVE);
    const noteIndex = i % NOTES_PER_OCTAVE;
    return {
      note: `${NOTE_NAMES[noteIndex]}${octave}`,
      position: i,
      isBlackKey: [1, 3, 6, 8, 10].includes(noteIndex)
    };
  }).reverse(); // Reverse so higher notes are at the top

  // Utility functions for coordinate conversion and note manipulation
  
  // Convert MIDI note number to y position
  const noteToY = (midiNote) => {
    return (TOTAL_NOTES - 1 - (midiNote - 21)) * NOTE_HEIGHT;
  };
  
  // Convert y position to MIDI note number
  const yToNote = (y) => {
    const noteIndex = Math.floor(y / NOTE_HEIGHT);
    return Math.min(Math.max(21, 127 - noteIndex), 108);
  };
  
  // Convert beat position to x position
  const beatToX = (beat) => {
    return beat * GRID_SIZE;
  };
  
  // Convert x position to beat position
  const xToBeat = (x) => {
    return Math.max(0, Math.floor(x / GRID_SIZE) * 0.25);
  };
  
  // Event handlers
  
  // Handle mouse down on the grid
  const handleGridMouseDown = (e) => {
    if (!gridRef.current) return;
    
    const rect = gridRef.current.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    setMouseDown(true);
    setStartPosition({ x, y });
    
    // Check if clicking on an existing note
    const clickedNote = notes.find(note => {
      const noteX = beatToX(note.start);
      const noteY = noteToY(note.midiNote);
      const noteEndX = noteX + beatToX(note.duration);
      
      return (
        x >= noteX && x <= noteEndX &&
        y >= noteY && y <= noteY + NOTE_HEIGHT
      );
    });
    
    if (clickedNote) {
      // Check if clicking on the resize handle (right edge)
      const noteX = beatToX(clickedNote.start);
      const noteEndX = noteX + beatToX(clickedNote.duration);
      
      if (x >= noteEndX - 10 && x <= noteEndX) {
        setIsResizing(true);
        setSelectedNote(clickedNote.id);
        return;
      }
      
      setDraggedNote(clickedNote.id);
      setSelectedNote(clickedNote.id);
      
      // Apply velocity to selected note if velocity editor is showing
      if (showVelocityEditor) {
        applyVelocity([clickedNote.id], velocityValue);
      }
    } else {
      // Get MIDI note from Y position
      const midiNote = yToNote(y);
      const beat = xToBeat(x);
      
      if (chordMode) {
        // Generate chord instead of single note
        generateChord(midiNote);
      } else if (patternMode) {
        // Apply melodic pattern
        applyMelodicPattern(midiNote);
      } else {
        // Create a new note
        let newNote = {
          id: Date.now(),
          midiNote,
          start: beat,
          duration: 4 / gridResolution, // Based on grid resolution
          velocity: velocityValue
        };
        
        // Apply scale snapping if enabled
        if (snapToScale) {
          const snappedNote = MusicTheory.snapNotesToScale([newNote], currentKey, currentScale)[0];
          newNote = snappedNote || newNote;
        }
        
        setNotes([...notes, newNote]);
        setSelectedNote(newNote.id);
      }
    }
  };
  
  // Handle mouse move on the grid
  const handleGridMouseMove = (e) => {
    if (!mouseDown || !gridRef.current) return;
    
    const rect = gridRef.current.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    if (isResizing) {
      // Resize the note
      setNotes(notes.map(note => {
        if (note.id === selectedNote) {
          const newDuration = Math.max(0.25, xToBeat(x) - note.start);
          return { ...note, duration: newDuration };
        }
        return note;
      }));
    } else if (draggedNote) {
      // Move the note
      setNotes(notes.map(note => {
        if (note.id === draggedNote) {
          const deltaX = x - startPosition.x;
          const deltaY = y - startPosition.y;
          
          const newBeat = Math.max(0, xToBeat(beatToX(note.start) + deltaX));
          const newMidiNote = Math.min(Math.max(21, note.midiNote + Math.round(deltaY / NOTE_HEIGHT * -1)), 108);
          
          return { ...note, start: newBeat, midiNote: newMidiNote };
        }
        return note;
      }));
      
      setStartPosition({ x, y });
    } else if (selectedNote) {
      // Resize the new note being created
      const beat = xToBeat(x);
      
      setNotes(notes.map(note => {
        if (note.id === selectedNote) {
          const duration = Math.max(0.25, beat - note.start);
          return { ...note, duration };
        }
        return note;
      }));
    }
  };
  
  // Handle mouse up
  const handleMouseUp = () => {
    setMouseDown(false);
    setDraggedNote(null);
    setIsResizing(false);
  };

  // Handle deleting a note
  const deleteNote = (id) => {
    setNotes(notes.filter(note => note.id !== id));
    if (selectedNote === id) {
      setSelectedNote(null);
    }
  };
  
  // Handle octave change
  const changeOctave = (delta) => {
    const newOctave = Math.min(Math.max(0, currentOctave + delta), 7);
    setCurrentOctave(newOctave);
  };
  
  // Handle playback start
  const startPlayback = () => {
    if (isPlaying) return;
    setIsPlaying(true);
    
    // Calculate time per 16th note in milliseconds
    const timePerBeat = 60000 / bpm;
    const timePerSixteenth = timePerBeat / 4;
    
    // Reset playhead position
    setPlayheadPosition(viewportStart);
    
    // Set up the interval to move the playhead
    playIntervalRef.current = setInterval(() => {
      setPlayheadPosition(prevPos => {
        const newPos = prevPos + 0.25; // Move by 1/16th note
        
        // Auto-scroll if enabled
        if (autoScroll && gridRef.current) {
          const gridWidth = gridRef.current.clientWidth;
          if (beatToX(newPos) > viewportStart + gridWidth * 0.7) {
            setViewportStart(prevStart => prevStart + GRID_SIZE);
          }
        }
        
        return newPos;
      });
    }, timePerSixteenth);
  };
  
  // Handle playback stop
  const stopPlayback = () => {
    setIsPlaying(false);
    if (playIntervalRef.current) {
      clearInterval(playIntervalRef.current);
      playIntervalRef.current = null;
    }
  };
  
  // Handle recording toggle
  const toggleRecording = () => {
    if (isRecording) {
      setIsRecording(false);
      stopPlayback();
    } else {
      setIsRecording(true);
      startPlayback();
    }
  };
  
  // Update grid resolution
  const updateGridResolution = (resolution) => {
    setGridResolution(resolution);
  };
  
  // Calculate beats per measure from time signature
  const getBeatsPerMeasure = () => {
    return parseInt(timeSignature.split('/')[0]);
  };
  
  // Apply scale snapping to notes
  const applyScaleSnapping = (notesToSnap = notes) => {
    if (!snapToScale) return notesToSnap;
    
    const snappedNotes = MusicTheory.snapNotesToScale(notesToSnap, currentKey, currentScale);
    setNotes(snappedNotes);
    return snappedNotes;
  };
  
  // Quantize notes to grid
  const applyQuantization = (notesToQuantize = notes) => {
    const resolution = gridResolution;
    const quantizedNotes = MusicTheory.quantizeNotes(notesToQuantize, resolution);
    setNotes(quantizedNotes);
    return quantizedNotes;
  };
  
  // Generate a chord based on root note and chord type
  const generateChord = (midiNote) => {
    if (!chordMode) return;
    
    // Get note name from MIDI number
    const { note } = MusicTheory.getNoteFromMidi(midiNote);
    const octave = Math.floor(midiNote / 12) - 1;
    
    // Generate chord notes
    const chordNotes = MusicTheory.getChordNotes(note, currentChordType, octave);
    
    // Create notes for the piano roll
    const newNotes = chordNotes.map((noteNum, index) => ({
      id: Date.now() + index,
      midiNote: noteNum,
      start: xToBeat(startPosition.x),
      duration: 1, // Default to quarter note
      velocity: velocityValue
    }));
    
    // Apply scale snapping if enabled
    if (snapToScale) {
      const snappedNotes = MusicTheory.snapNotesToScale(newNotes, currentKey, currentScale);
      setNotes([...notes, ...snappedNotes]);
    } else {
      setNotes([...notes, ...newNotes]);
    }
  };

  // Apply melodic pattern starting from root note
  const applyMelodicPattern = (rootMidiNote) => {
    if (!patternMode) return;
    
    const beat = xToBeat(startPosition.x);
    const patternNotes = MelodyGenerator.generateMelodicPattern(
      rootMidiNote,
      selectedPattern,
      currentKey,
      currentScale,
      4 / gridResolution,
      velocityValue
    );
    
    // Add pattern type to each note
    const typedPatternNotes = patternNotes.map(note => ({
      ...note,
      type: 'pattern'
    }));
    
    setNotes([...notes, ...typedPatternNotes]);
  };
  
  // Generate variations of the current melody
  const generateVariation = (variationType) => {
    if (notes.length === 0) return;
    
    const variationNotes = MelodyGenerator.generateMelodyVariation(notes, variationType);
    setNotes(variationNotes);
    return variationNotes;
  };

  // Apply velocity to selected notes
  const applyVelocityToSelectedNotes = () => {
    if (!selectedNote && notes.length === 0) return;
    
    // If a note is selected, apply to that note only
    if (selectedNote) {
      applyVelocity([selectedNote], velocityValue);
      return;
    }
    
    // If no specific note is selected, apply to all notes
    const noteIds = notes.map(note => note.id);
    applyVelocity(noteIds, velocityValue);
  };

  // Enhance a melody generated from code using music theory
  const enhanceGeneratedMelody = (generatedNotes) => {
    // First snap to the current key and scale
    let enhancedNotes = MusicTheory.snapNotesToScale(generatedNotes, currentKey, currentScale);
    
    // Apply quantization if enabled
    if (quantizeEnabled) {
      enhancedNotes = MusicTheory.quantizeNotes(enhancedNotes, gridResolution);
    }
    
    // Add velocity variation for more expression
    enhancedNotes = enhancedNotes.map(note => ({
      ...note,
      velocity: note.velocity || (70 + Math.floor(Math.random() * 30))
    }));
    
    return enhancedNotes;
  };
  
  // Toggle advanced controls visibility
  const toggleAdvancedControls = () => {
    setShowAdvancedControls(!showAdvancedControls);
  };
  
  // Clean up on unmount
  useEffect(() => {
    return () => {
      if (playIntervalRef.current) {
        clearInterval(playIntervalRef.current);
      }
    };
  }, []);
  
  // Attach and detach event listeners
  useEffect(() => {
    document.addEventListener('mouseup', handleMouseUp);
    document.addEventListener('mousemove', handleGridMouseMove);
    
    return () => {
      document.removeEventListener('mouseup', handleMouseUp);
      document.removeEventListener('mousemove', handleGridMouseMove);
    };
  }, [mouseDown, draggedNote, startPosition, isResizing, selectedNote]);

  return (
    <div className="piano-roll-container">
      {/* Header with controls */}
      <div className="piano-roll-header">
        <div className="piano-roll-title">Piano Roll Editor</div>
        <div className="piano-roll-settings">
          <div className="setting-group">
            <label>BPM:</label>
            <input 
              type="number" 
              value={bpm} 
              onChange={(e) => setBpm(parseInt(e.target.value))} 
              min="40" 
              max="300"
              className="bpm-input"
            />
          </div>
          <div className="setting-group">
            <label>Time:</label>
            <select 
              value={timeSignature} 
              onChange={(e) => setTimeSignature(e.target.value)}
              className="time-sig-select"
            >
              <option value="4/4">4/4</option>
              <option value="3/4">3/4</option>
              <option value="6/8">6/8</option>
            </select>
          </div>
          <div className="setting-group">
            <label>Grid:</label>
            <select 
              value={gridResolution} 
              onChange={(e) => updateGridResolution(parseInt(e.target.value))}
              className="grid-res-select"
            >
              <option value="4">1/4</option>
              <option value="8">1/8</option>
              <option value="16">1/16</option>
              <option value="32">1/32</option>
            </select>
          </div>
          <div className="setting-group">
            <button onClick={() => changeOctave(-1)} disabled={currentOctave <= 0} className="octave-btn">
              <FontAwesomeIcon icon={faMinus} /> Octave
            </button>
            <div className="current-octave">O: {currentOctave}</div>
            <button onClick={() => changeOctave(1)} disabled={currentOctave >= 7} className="octave-btn">
              <FontAwesomeIcon icon={faPlus} /> Octave
            </button>
          </div>
        </div>
      </div>
      
      {/* Timeline ruler at the top */}
      <div className="timeline-ruler" style={{ height: TIMELINE_HEIGHT, marginLeft: PIANO_KEY_WIDTH }}>
        {Array(MEASURES).fill().map((_, i) => (
          <div key={i} className="measure-marker">
            <span className="measure-number">{i + 1}</span>
          </div>
        ))}
      </div>
      
      {/* Piano roll main area */}
      <div className="piano-roll-wrapper" ref={pianoRollRef} style={{ transform: `translateX(-${viewportStart}px)` }}>
        {/* Piano keys on the left */}
        <div className="piano-keys">
          {notePositions.map(({ note, position, isBlackKey }) => (
            <div
              key={position}
              className={`piano-key ${isBlackKey ? 'black-key' : 'white-key'} ${note.includes('C') ? 'c-note' : ''}`}
              style={{ height: NOTE_HEIGHT }}
            >
              {note.includes('C') && <span className="note-label">{note}</span>}
              {!note.includes('C') && note.includes('F') && <span className="note-label small">{note}</span>}
            </div>
          ))}
        </div>
        
        {/* Main grid */}
        <div 
          className="piano-grid" 
          ref={gridRef}
          onMouseDown={handleGridMouseDown}
        >
          {/* Playhead indicator */}
          {isPlaying && (
            <div 
              ref={playheadRef}
              className="playhead"
              style={{
                left: beatToX(playheadPosition),
                height: '100%'
              }}
            />
          )}

          {/* Horizontal lines for each note */}
          {notePositions.map(({ note, position }) => (
            <React.Fragment key={position}>
              <div
                className={`grid-line horizontal ${note.includes('C') ? 'octave-line' : ''}`}
                style={{ top: position * NOTE_HEIGHT, height: NOTE_HEIGHT }}
              />
              {/* Highlight notes in the selected scale if snap to scale is enabled */}
              {snapToScale && note.includes(currentKey) && MusicTheory.isNoteInScale(note, currentKey, currentScale) && (
                <div 
                  className="grid-highlight" 
                  style={{ 
                    top: position * NOTE_HEIGHT,
                    height: NOTE_HEIGHT 
                  }} 
                />
              )}
            </React.Fragment>
          ))}
          
          {/* Vertical lines for beat divisions */}
          {Array(MEASURES * 16 + 1).fill().map((_, i) => {
            const beatInMeasure = i % 16;
            const isMeasureLine = beatInMeasure === 0;
            const isBeatLine = beatInMeasure % 4 === 0;
            return (
              <div 
                key={i} 
                className={`grid-line vertical ${isMeasureLine ? 'bar-line' : ''} ${isBeatLine ? 'beat-line' : ''}`}
                style={{ left: i * (GRID_SIZE / 4) }}
              />
            );
          })}
          
          {/* Render notes */}
          {notes.map((note) => {
            const x = beatToX(note.start);
            const y = noteToY(note.midiNote);
            const noteWidth = beatToX(note.duration);
            
            return (
              <div 
                key={note.id}
                className={`note ${selectedNote === note.id ? 'selected' : ''} ${note.type === 'chord' ? 'chord-note' : ''} ${note.type === 'pattern' ? 'pattern-note' : ''}`}
                style={{ 
                  left: `${x}px`, 
                  top: `${y}px`, 
                  width: `${noteWidth}px`,
                  height: `${NOTE_HEIGHT}px`,
                  opacity: Math.max(0.5, Math.min(1, (note.velocity || 100) / 127))
                }}
                onMouseDown={(e) => {
                  e.stopPropagation();
                  const rect = e.currentTarget.getBoundingClientRect();
                  const x = e.clientX - rect.left;
                  const y = e.clientY - rect.top;
                  setMouseDown(true);
                  setStartPosition({ x, y });
                  setSelectedNote(note.id);
                  setDraggedNote(note.id);
                }}
              >
                <div className="note-label">
                  {NOTE_NAMES[note.midiNote % 12] + Math.floor(note.midiNote / 12 - 1)}
                </div>
                <div 
                  className="note-resize-handle"
                  onMouseDown={(e) => {
                    e.stopPropagation();
                    setIsResizing(true);
                    setSelectedNote(note.id);
                    setMouseDown(true);
                  }}
                />
                <div 
                  className="note-delete"
                  onClick={(e) => {
                    e.stopPropagation();
                    deleteNote(note.id);
                  }}
                >
                  ×
                </div>
                {/* Note velocity indicator - subtle visual cue */}
                {note.velocity && (
                  <div 
                    className="velocity-indicator"
                    style={{
                      position: 'absolute',
                      bottom: '2px',
                      left: '4px',
                      right: '4px',
                      height: '3px',
                      background: `rgba(255, 255, 255, ${Math.min(1, note.velocity / 127) * 0.8})`,
                      borderRadius: '1px'
                    }}
                  />
                )}
              </div>
            );
          })}
        </div>
      </div>
      
      {/* Velocity editor */}
      {showVelocityEditor && (
        <div className="velocity-editor">
          {notes.map((note) => {
            const x = beatToX(note.start);
            const width = Math.max(4, beatToX(note.duration));
            const height = Math.min(60, Math.max(5, (note.velocity || 100) / 127 * 60));
            
            return (
              <div 
                key={`velocity-${note.id}`}
                className={`velocity-bar ${selectedNote === note.id ? 'selected' : ''}`}
                style={{
                  left: `${x}px`,
                  width: `${width}px`,
                  height: `${height}px`,
                  marginRight: '1px'
                }}
                onClick={() => {
                  setSelectedNote(note.id);
                }}
                onDoubleClick={() => {
                  applyVelocity([note.id], velocityValue);
                }}
              />
            );
          })}
        </div>
      )}
      
      {/* Transport controls */}
      <div className="transport-controls" style={{ height: TRANSPORT_HEIGHT }}>
        <div className="transport-buttons">
          <button 
            className={`transport-button ${isPlaying ? 'active' : ''}`} 
            onClick={isPlaying ? stopPlayback : startPlayback}
          >
            <FontAwesomeIcon icon={isPlaying ? faStop : faPlay} />
            <span className="btn-label">{isPlaying ? 'Stop' : 'Play'}</span>
          </button>
          <button 
            className={`transport-button ${isRecording ? 'recording' : ''}`} 
            onClick={toggleRecording}
          >
            <FontAwesomeIcon icon={faRecordVinyl} />
            <span className="btn-label">Record</span>
          </button>
        </div>
        <div className="transport-position">
          <span className="position-display">
            {Math.floor(playheadPosition / getBeatsPerMeasure()) + 1}.{Math.floor((playheadPosition % getBeatsPerMeasure()) * 4) + 1}.{Math.floor(((playheadPosition * 4) % 4) * 4) + 1}
          </span>
        </div>
        <div className="transport-right">
          <button 
            className={`transport-button ${showAdvancedControls ? 'active' : ''}`}
            onClick={toggleAdvancedControls}
          >
            <FontAwesomeIcon icon={faSliders} />
            <span className="btn-label">Advanced</span>
          </button>
          <label className="auto-scroll-label">
            <input 
              type="checkbox" 
              checked={autoScroll} 
              onChange={(e) => setAutoScroll(e.target.checked)} 
            />
            Auto-scroll
          </label>
        </div>
      </div>
      
      {showAdvancedControls && (
        <div className="advanced-controls-panel">
          <div className="advanced-controls-section">
            <h3>Music Theory</h3>
            <div className="control-row">
              <label>
                Key:
                <select 
                  value={currentKey} 
                  onChange={(e) => setCurrentKey(e.target.value)}
                >
                  {MusicTheory.NOTES.map(note => (
                    <option key={note} value={note}>{note}</option>
                  ))}
                </select>
              </label>
              <label>
                Scale:
                <select 
                  value={currentScale} 
                  onChange={(e) => setCurrentScale(e.target.value)}
                >
                  {Object.keys(MusicTheory.SCALES).map(scale => (
                    <option key={scale} value={scale}>{scale.replace(/([A-Z])/g, ' $1').trim()}</option>
                  ))}
                </select>
              </label>
            </div>
            <div className="control-row">
              <label className="checkbox-label">
                <input 
                  type="checkbox" 
                  checked={snapToScale} 
                  onChange={(e) => setSnapToScale(e.target.checked)} 
                />
                Snap to Scale
              </label>
              <button 
                className="tool-button" 
                onClick={() => applyScaleSnapping()}
                title="Apply scale snapping to all notes"
              >
                <FontAwesomeIcon icon={faMusic} />
                Apply to All Notes
              </button>
            </div>
          </div>
          
          <div className="advanced-controls-section">
            <h3>Editing Tools</h3>
            <div className="control-row">
              <button 
                className={`tool-button ${chordMode ? 'active' : ''}`}
                onClick={() => setChordMode(!chordMode)}
                title="Click a note to create a chord"
              >
                <FontAwesomeIcon icon={faMusic} />
                Chord Mode
              </button>
              <label>
                Chord Type:
                <select 
                  value={currentChordType} 
                  onChange={(e) => setCurrentChordType(e.target.value)}
                  disabled={!chordMode}
                >
                  {Object.keys(MusicTheory.CHORD_TYPES).map(type => (
                    <option key={type} value={type}>{type}</option>
                  ))}
                </select>
              </label>
            </div>
            
            <div className="control-row">
              <button 
                className={`tool-button ${patternMode ? 'active' : ''}`}
                onClick={() => setPatternMode(!patternMode)}
                title="Click a note to create a melodic pattern"
              >
                <FontAwesomeIcon icon={faWaveSquare} />
                Pattern Mode
              </button>
              <label>
                Pattern:
                <select 
                  value={selectedPattern} 
                  onChange={(e) => setSelectedPattern(e.target.value)}
                  disabled={!patternMode}
                >
                  {Object.keys(MelodyGenerator.MELODIC_PATTERNS).map(pattern => (
                    <option key={pattern} value={pattern}>{pattern}</option>
                  ))}
                </select>
              </label>
            </div>
            
            <div className="control-row">
              <label className="checkbox-label">
                <input 
                  type="checkbox" 
                  checked={quantizeEnabled} 
                  onChange={(e) => setQuantizeEnabled(e.target.checked)} 
                />
                Quantize
              </label>
              <button 
                className="tool-button" 
                onClick={() => applyQuantization()}
                disabled={!quantizeEnabled}
                title="Align notes to grid"
              >
                <FontAwesomeIcon icon={faArrowsAlt} />
                Quantize Notes
              </button>
              <label>
                Grid:
                <select 
                  value={gridResolution} 
                  onChange={(e) => updateGridResolution(parseInt(e.target.value))}
                >
                  <option value="4">1/4 Note</option>
                  <option value="8">1/8 Note</option>
                  <option value="16">1/16 Note</option>
                  <option value="32">1/32 Note</option>
                </select>
              </label>
            </div>
          </div>
          
          <div className="advanced-controls-section">
            <h3>Variations</h3>
            <div className="control-row variation-buttons">
              <button 
                className="tool-button" 
                onClick={() => generateVariation('rhythm')}
                title="Create a rhythm variation of the current melody"
              >
                Rhythm Variation
              </button>
              <button 
                className="tool-button" 
                onClick={() => generateVariation('pitch')}
                title="Create a pitch variation of the current melody"
              >
                Pitch Variation
              </button>
              <button 
                className="tool-button" 
                onClick={() => generateVariation('inversion')}
                title="Invert the intervals of the current melody"
              >
                Inversion
              </button>
              <button 
                className="tool-button" 
                onClick={() => generateVariation('retrograde')}
                title="Reverse the current melody"
              >
                Retrograde
              </button>
            </div>
          </div>
          
          <div className="advanced-controls-section">
            <h3>Note Velocity</h3>
            <div className="control-row">
              <label className="checkbox-label">
                <input 
                  type="checkbox" 
                  checked={showVelocityEditor} 
                  onChange={(e) => setShowVelocityEditor(e.target.checked)} 
                />
                Show Velocity Editor
              </label>
              <input 
                type="range" 
                min="1" 
                max="127" 
                value={velocityValue} 
                onChange={(e) => setVelocityValue(parseInt(e.target.value))} 
              />
              <span className="velocity-value">{velocityValue}</span>
              <button 
                className="tool-button" 
                onClick={() => applyVelocityToSelectedNotes()}
                title="Apply current velocity to selected notes"
              >
                <FontAwesomeIcon icon={faVolumeUp} />
                Apply Velocity
              </button>
            </div>
          </div>
        </div>
      )}
      {/* Transport controls */}
      <div className="transport-controls" style={{ height: TRANSPORT_HEIGHT }}>
        <div className="transport-buttons">
          <button 
            className={`transport-button ${isPlaying ? 'active' : ''}`} 
            onClick={isPlaying ? stopPlayback : startPlayback}
          >
            <FontAwesomeIcon icon={isPlaying ? faStop : faPlay} />
            <span className="btn-label">{isPlaying ? 'Stop' : 'Play'}</span>
          </button>
          <button 
            className={`transport-button ${isRecording ? 'recording' : ''}`} 
            onClick={toggleRecording}
          >
            <FontAwesomeIcon icon={faRecordVinyl} />
            <span className="btn-label">Record</span>
          </button>
        </div>
        <div className="transport-position">
          <span className="position-display">
            {Math.floor(playheadPosition / getBeatsPerMeasure()) + 1}.{Math.floor((playheadPosition % getBeatsPerMeasure()) * 4) + 1}.{Math.floor(((playheadPosition * 4) % 4) * 4) + 1}
          </span>
        </div>
        <div className="transport-right">
          <button 
            className={`transport-button ${showAdvancedControls ? 'active' : ''}`}
            onClick={toggleAdvancedControls}
          >
            <FontAwesomeIcon icon={faSliders} />
            <span className="btn-label">Advanced</span>
          </button>
          <label className="auto-scroll-label">
            <input 
              type="checkbox" 
              checked={autoScroll} 
              onChange={(e) => setAutoScroll(e.target.checked)} 
            />
            Auto-scroll
          </label>
        </div>
      </div>
      
      {/* Advanced controls panel */}
      {showAdvancedControls && (
        <div className="advanced-controls-panel">
          <div className="advanced-controls-section">
            <h3>Music Theory</h3>
            <div className="control-row">
              <label>
                Key:
                <select 
                  value={currentKey} 
                  onChange={(e) => setCurrentKey(e.target.value)}
                >
                  {MusicTheory.NOTES.map(note => (
                    <option key={note} value={note}>{note}</option>
                  ))}
                </select>
              </label>
              <label>
                Scale:
                <select 
                  value={currentScale} 
                  onChange={(e) => setCurrentScale(e.target.value)}
                >
                  {Object.keys(MusicTheory.SCALES).map(scale => (
                    <option key={scale} value={scale}>{scale.replace(/([A-Z])/g, ' $1').trim()}</option>
                  ))}
                </select>
              </label>
            </div>
            <div className="control-row">
              <label className="checkbox-label">
                <input 
                  type="checkbox" 
                  checked={snapToScale} 
                  onChange={(e) => setSnapToScale(e.target.checked)} 
                />
                Snap to Scale
              </label>
              <button 
                className="tool-button" 
                onClick={() => applyScaleSnapping()}
              >
                <FontAwesomeIcon icon={faMusic} />
                Apply to All Notes
              </button>
            </div>
          </div>
          
          <div className="advanced-controls-section">
            <h3>Editing Tools</h3>
            <div className="control-row">
              <button 
                className={`tool-button ${chordMode ? 'active' : ''}`}
                onClick={() => setChordMode(!chordMode)}
                title="Click a note to create a chord"
              >
                <FontAwesomeIcon icon={faMusic} />
                Chord Mode
              </button>
              <label>
                Chord Type:
                <select 
                  value={currentChordType} 
                  onChange={(e) => setCurrentChordType(e.target.value)}
                  disabled={!chordMode}
                >
                  {Object.keys(MusicTheory.CHORD_TYPES).map(type => (
                    <option key={type} value={type}>{type}</option>
                  ))}
                </select>
              </label>
            </div>
            
            <div className="control-row">
              <button 
                className={`tool-button ${patternMode ? 'active' : ''}`}
                onClick={() => setPatternMode(!patternMode)}
                title="Click a note to create a melodic pattern"
              >
                <FontAwesomeIcon icon={faWaveSquare} />
                Pattern Mode
              </button>
              <label>
                Pattern:
                <select 
                  value={selectedPattern} 
                  onChange={(e) => setSelectedPattern(e.target.value)}
                  disabled={!patternMode}
                >
                  {Object.keys(MelodyGenerator.MELODIC_PATTERNS).map(pattern => (
                    <option key={pattern} value={pattern}>{pattern}</option>
                  ))}
                </select>
              </label>
            </div>
            
            <div className="control-row">
              <label className="checkbox-label">
                <input 
                  type="checkbox" 
                  checked={quantizeEnabled} 
                  onChange={(e) => setQuantizeEnabled(e.target.checked)} 
                />
                Quantize
              </label>
              <button 
                className="tool-button" 
                onClick={() => applyQuantization()}
                disabled={!quantizeEnabled}
                title="Align notes to grid"
              >
                <FontAwesomeIcon icon={faArrowsAlt} />
                Quantize Notes
              </button>
              <label>
                Grid:
                <select 
                  value={gridResolution} 
                  onChange={(e) => updateGridResolution(parseInt(e.target.value))}
                >
                  <option value="4">1/4 Note</option>
                  <option value="8">1/8 Note</option>
                  <option value="16">1/16 Note</option>
                  <option value="32">1/32 Note</option>
                </select>
              </label>
            </div>
          </div>
          
          <div className="advanced-controls-section">
            <h3>Variations</h3>
            <div className="control-row variation-buttons">
              <button 
                className="tool-button" 
                onClick={() => generateVariation('rhythm')}
                title="Create a rhythm variation of the current melody"
              >
                Rhythm Variation
              </button>
              <button 
                className="tool-button" 
                onClick={() => generateVariation('pitch')}
                title="Create a pitch variation of the current melody"
              >
                Pitch Variation
              </button>
              <button 
                className="tool-button" 
                onClick={() => generateVariation('inversion')}
                title="Invert the intervals of the current melody"
              >
                Inversion
              </button>
              <button 
                className="tool-button" 
                onClick={() => generateVariation('retrograde')}
                title="Reverse the current melody"
              >
                Retrograde
              </button>
            </div>
          </div>
          
          <div className="advanced-controls-section">
            <h3>Note Velocity</h3>
            <div className="control-row">
              <label className="checkbox-label">
                <input 
                  type="checkbox" 
                  checked={showVelocityEditor} 
                  onChange={(e) => setShowVelocityEditor(e.target.checked)} 
                />
                Show Velocity Editor
              </label>
              <input 
                type="range" 
                min="1" 
                max="127" 
                value={velocityValue} 
                onChange={(e) => setVelocityValue(parseInt(e.target.value))} 
              />
              <span className="velocity-value">{velocityValue}</span>
              <button 
                className="tool-button" 
                onClick={() => applyVelocityToSelectedNotes()}
                title="Apply current velocity to selected notes"
              >
                <FontAwesomeIcon icon={faVolumeUp} />
                Apply Velocity
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default PianoRoll;
